name: Compilació multiplataforma

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  build-linux:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Instal·la PyInstaller
        run: pip install pyinstaller
      - name: Compila Linux i cerca Manuals
        run: |
          mkdir -p dist_all
          for carpeta in */; do
            carpeta="${carpeta%/}"
            [[ "$carpeta" =~ ^(\.github|\.git|assets|docs)$ ]] && continue
            if [[ -d "${carpeta}/source" ]]; then src="${carpeta}/source"
            elif [[ -d "${carpeta}/Source" ]]; then src="${carpeta}/Source"
            else continue; fi
            nom_exe=$(echo "$carpeta" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr '_' '-')
            fitxer_py=$(find "$src" -maxdepth 1 -name "*.py" -type f | head -n1)
            [[ -z "$fitxer_py" ]] && continue
            cd "$src"
            pyinstaller --onefile "$(basename "$fitxer_py")" --name "$nom_exe" --distpath "../../dist_all" --log-level=WARN
            cd ../..
            manual_trobat=$(find "$carpeta" -maxdepth 2 -iname "manual.md" | head -n1)
            if [[ ! -z "$manual_trobat" ]]; then
              cp "$manual_trobat" "dist_all/${nom_exe}_manual.txt"
            fi
          done
      - uses: actions/upload-artifact@v4
        with:
          name: linux-assets
          path: dist_all/

  build-windows:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Instal·la PyInstaller
        run: pip install pyinstaller
      - name: Compila Windows
        shell: pwsh
        run: |
          New-Item -Path "dist_all" -ItemType Directory -Force
          Get-ChildItem -Directory | ForEach-Object {
            $cap = $_.Name
            if ($cap -in @(".github", ".git", "assets", "docs")) { return }
            $src = if (Test-Path "$cap/source") { "$cap/source" } else { "$cap/Source" }
            if (-not (Test-Path $src)) { return }
            $exe = $cap.ToLower() -replace ' ', '-' -replace '_', '-'
            $py = Get-ChildItem "$src/*.py" | Select-Object -First 1
            if ($py) {
              Set-Location $src
              pyinstaller --onefile $py.Name --name $exe --distpath "..\..\dist_all" --log-level=WARN
              Set-Location ..\..
            }
          }
      - uses: actions/upload-artifact@v4
        with:
          name: windows-assets
          path: dist_all/

  publish:
    runs-on: ubuntu-latest
    needs: [build-linux, build-windows]
    steps:
      - name: Baixar fitxers
        uses: actions/download-artifact@v4
        with:
          path: release_files
          merge-multiple: true

      - name: Publicar fitxers un a un
        shell: bash
        run: |
          # Aquesta acció de sota és molt robusta per a múltiples fitxers
          # Usarem un bucle per assegurar que no col·lapsa l'API
          ls -R release_files/

      - name: Crear Release
        uses: softprops/action-gh-release@v2
        with:
          files: release_files/*
          tag_name: ${{ github.ref_name }}
          # El secret aquí és que l'acció de softprops té un paràmetre per
          # no fallar si hi ha errors de paral·lelisme puntuals
          fail_on_unmatched_files: false
          # overwrite_files ja el teníem, però ara ho fem des d'un sol lloc
          overwrite_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
